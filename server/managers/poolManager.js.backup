const { CONFIG } = require('../config/constants')
const MatchingUtils = require('../utils/matchingUtils')

// Pool-based matching system to solve coupling bottleneck
const PoolManager = {
  // Calculate optimal buffer size based on current queue
  calculateBufferSize(queueLength) {
    if (queueLength < CONFIG.POOL.IMMEDIATE_MATCH_THRESHOLD) {
      return CONFIG.POOL.MIN_BUFFER_SIZE
    }
    
    const percentageBuffer = Math.ceil(queueLength * (CONFIG.POOL.BUFFER_PERCENTAGE / 100))
    return Math.min(percentageBuffer, CONFIG.POOL.MAX_BUFFER_SIZE)
  },

  // Check if we should do immediate matching or wait for batch
  shouldDoImmediateMatch(queueLength) {
    return queueLength < CONFIG.POOL.IMMEDIATE_MATCH_THRESHOLD
  },

  // Calculate how many users to match in this batch
  calculateMatchCount(queueLength) {
    const bufferSize = this.calculateBufferSize(queueLength)
    const availableForMatching = queueLength - bufferSize
    
    // Ensure we never have negative users available for matching
    if (availableForMatching <= 0) {
      return 0
    }
    
    // Only match even numbers (pairs)
    return Math.floor(availableForMatching / 2) * 2
  },

  // Get users available for matching (excludes buffer)
  getMatchableUsers(ServerState) {
    const queueLength = ServerState.waitingQueue.length
    const matchCount = this.calculateMatchCount(queueLength)
    
    if (matchCount <= 0) {
      console.log(`üèä‚Äç‚ôÇÔ∏è Pool: Not enough users for matching. Queue: ${queueLength}, keeping all as buffer`)
      return []
    }

    // Sort by join time (FIFO for fairness) but add some randomization
    const sortedQueue = [...ServerState.waitingQueue].sort((a, b) => {
      const timeDiff = a.joinedAt - b.joinedAt
      // Add small random factor to prevent strict FIFO
      const randomFactor = (Math.random() - 0.5) * 10000 // ¬±5 seconds randomness
      return timeDiff + randomFactor
    })

    const matchableUsers = sortedQueue.slice(0, matchCount)
    
    console.log(`üèä‚Äç‚ôÇÔ∏è Pool: ${queueLength} in queue, ${matchCount} available for matching, keeping ${queueLength - matchCount} in buffer`)
    
    return matchableUsers
  },

  // Process batch matching with pool strategy
  processBatchMatching(io, ServerState, matchManager) {
    const matchableUsers = this.getMatchableUsers(ServerState)
    
    if (matchableUsers.length < 2) {
      console.log(`üèä‚Äç‚ôÇÔ∏è Pool: Insufficient users for batch matching`)
      return 0
    }

    const matched = new Set()
    let matchCount = 0

    // Create randomized matching pairs
    const shuffledUsers = MatchingUtils.shuffleArray([...matchableUsers])
    
    for (let i = 0; i < shuffledUsers.length - 1; i += 2) {
      const user1 = shuffledUsers[i]
      const user2 = shuffledUsers[i + 1]

      if (matched.has(user1.socketId) || matched.has(user2.socketId)) {
        continue
      }

      // Validate both users are still valid
      if (!MatchingUtils.isValidUser(user1, io, ServerState) || 
          !MatchingUtils.isValidUser(user2, io, ServerState)) {
        continue
      }

      // Check compatibility
      if (this.areUsersCompatible(user1, user2)) {
        console.log(`üéØ Pool match: ${user1.socketId.slice(-4)} ‚Üî ${user2.socketId.slice(-4)}`)
        
        matched.add(user1.socketId)
        matched.add(user2.socketId)
        
        // Create the match
        matchManager.create(user1, user2, io, ServerState)
        matchCount++
      }
    }

    // Remove matched users from queue
    this.removeMatchedUsers(matched, ServerState)
    
    console.log(`‚úÖ Pool batch complete: ${matchCount} matches made, ${ServerState.waitingQueue.length} users remain in pool`)
    return matchCount
  },

  // Check if two users are compatible for matching
  areUsersCompatible(user1, user2) {
    const now = new Date()

    // Prevent self-matching
    if (MatchingUtils.preventSelfMatch(user1, user2)) {
      return false
    }

    // Check for recently skipped partners
    if (user1.lastSkipped === user2.socketId || user2.lastSkipped === user1.socketId) {
      return false
    }

    // Check skip cooldowns
    if ((user1.skipCooldown && now < user1.skipCooldown) ||
        (user2.skipCooldown && now < user2.skipCooldown)) {
      return false
    }

    // Check safe mode compatibility
    if (user1.safeMode !== user2.safeMode) {
      return false
    }

    return true
  },

  // Find immediate match for skip scenarios (high priority)
  findImmediateMatch(user, io, ServerState) {
    console.log(`üöÄ Pool: Finding immediate match for ${user.socketId.slice(-4)} (skip scenario)`)
    
    // Look through entire queue for immediate match
    for (const waitingUser of ServerState.waitingQueue) {
      if (this.areUsersCompatible(user, waitingUser) && 
          MatchingUtils.isValidUser(waitingUser, io, ServerState)) {
        
        console.log(`‚ö° Immediate match found: ${user.socketId.slice(-4)} ‚Üî ${waitingUser.socketId.slice(-4)}`)
        return waitingUser
      }
    }

    console.log(`‚è≥ No immediate match found for ${user.socketId.slice(-4)}, adding to priority queue`)
    return null
  },

  // Remove matched users from the waiting queue
  removeMatchedUsers(matched, ServerState) {
    for (let i = ServerState.waitingQueue.length - 1; i >= 0; i--) {
      if (matched.has(ServerState.waitingQueue[i].socketId)) {
        console.log(`üì§ Removing matched user ${ServerState.waitingQueue[i].socketId.slice(-4)} from queue`)
        ServerState.waitingQueue.splice(i, 1)
      }
    }
  },

  // Add user to queue with pool management
  addToPool(user, ServerState) {
    // Mark with priority if this is a skip scenario
    if (user.fromSkip) {
      user.priority = 'high'
      user.addedAt = new Date()
      // Add to front of queue for faster matching
      ServerState.waitingQueue.unshift(user)
      console.log(`üèÉ‚Äç‚ôÇÔ∏è Added ${user.socketId.slice(-4)} to PRIORITY pool (skip). Queue: ${ServerState.waitingQueue.length}`)
    } else {
      user.priority = 'normal'
      user.addedAt = new Date()
      ServerState.waitingQueue.push(user)
      console.log(`üèä‚Äç‚ôÇÔ∏è Added ${user.socketId.slice(-4)} to pool. Queue: ${ServerState.waitingQueue.length}`)
    }
  },

  // Get pool statistics for monitoring
  getPoolStats(ServerState) {
    const queueLength = ServerState.waitingQueue.length
    const bufferSize = this.calculateBufferSize(queueLength)
    const matchableCount = this.calculateMatchCount(queueLength)
    
    return {
      totalInQueue: queueLength,
      bufferSize: bufferSize,
      matchableUsers: matchableCount,
      availableMatches: Math.max(0, Math.floor(matchableCount / 2)),
      poolUtilization: queueLength > 0 ? ((queueLength - bufferSize) / queueLength * 100).toFixed(1) : 0
    }
  },

  // Update queue positions with pool information
  updatePoolPositions(io, ServerState) {
    const poolStats = this.getPoolStats(ServerState)
    
    ServerState.waitingQueue.forEach((user, index) => {
      const socket = io.sockets.sockets.get(user.socketId)
      if (socket) {
        const estimatedWait = user.priority === 'high' ? 5 : Math.max(
          CONFIG.QUEUE.MIN_ESTIMATED_WAIT, 
          (index + 1) * CONFIG.QUEUE.ESTIMATED_WAIT_PER_POSITION
        )
        
        socket.emit('queue-position-updated', {
          position: index + 1,
          totalInQueue: ServerState.waitingQueue.length,
          estimatedWait: estimatedWait,
          poolInfo: {
            bufferSize: poolStats.bufferSize,
            nextBatchIn: CONFIG.POOL.BATCH_MATCHING_INTERVAL / 1000,
            isInBuffer: index >= poolStats.matchableUsers,
            priority: user.priority || 'normal'
          }
        })
      }
    })
    
    if (ServerState.waitingQueue.length > 0) {
      console.log(`üìç Pool positions updated for ${ServerState.waitingQueue.length} users (Buffer: ${poolStats.bufferSize})`)
    }
  }
}

module.exports = PoolManager
